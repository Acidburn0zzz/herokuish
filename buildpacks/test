#!/bin/bash

# called by test.sh stub in app tests
app-test() {
  declare app="$1"
  eval "
    T_$app() {
      run-test $app
    }
  "
}

# runs the generic app test
run-test() {
  [[ "$TRACE" ]] && set -x
  declare app="$1"
  local buildpack="buildpack-${1%%-*}"
  cd "$(dirname $BASH_SOURCE)"
  local app_path="$PWD/$buildpack/tests/$app"
  cd - &> /dev/null
	[[ "$CI" ]] || rmflag="--rm"
  [[ "$TRACE" ]] && debug_flag="-e TRACE=true"
  run-invalid-proc-test
  docker run $rmflag $debug_flag --env=USER=herokuishuser -v "$app_path:/tmp/app" herokuish:dev /bin/herokuish test / "$app"
}

run-invalid-proc-test() {
  echo "Running /start with invalid Proc Process"
  local expected_err_msg="Proc entrypoint invalid-proc does not exist. Please check your Procfile"
  local err_msg="$(docker run $rmflag $debug_flag --env=USER=herokuishuser -v "$app_path:/tmp/app" herokuish:dev /start invalid-proc)"
  if [[ $err_msg != $expected_err_msg ]]; then
    echo "/start did not throw error for invalid procfile"
    exit 1
  fi
}

main() {
  case "$#" in
    0)  # no args, run all the tests!
        cd "$(dirname $BASH_SOURCE)"
        basht $PWD/buildpack*/tests/*/test.sh
        ;;

    1)  # one arg, expect name of buildpack to test
        cd "$(dirname $BASH_SOURCE)"
        basht $PWD/$1/tests/*/test.sh
        ;;

    *)  # more args, pass directly to basht
        basht "$@"
        ;;
  esac
}

[[ "$0" == "$BASH_SOURCE" ]] && main "$@"
